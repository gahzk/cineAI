# -*- coding: utf-8 -*-
"""cineAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13NfksvVpmojLvMcqZVVV_nZKYVNt7T00
"""

import sys, subprocess, time, re, unicodedata, random, json, os, argparse
from collections import deque
import concurrent.futures as cf
from typing import Any, Dict, List

# --- Depend√™ncias e Instala√ß√£o ---
def _pip_install(p):
    try: __import__(p.split("==")[0])
    except ImportError: subprocess.check_call([sys.executable, "-m", "pip", "install", p, "-q"])

for dep in ["requests", "rapidfuzz", "rich"]: _pip_install(dep)

import requests
from rapidfuzz import fuzz, process
from rich.console import Console, Group
from rich.panel import Panel
from rich.prompt import Prompt, Confirm
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeElapsedColumn
from rich.rule import Rule
from rich.table import Table
from rich.text import Text
from rich.style import Style
from rich.box import MINIMAL

# --- Configura√ß√µes Globais e Tema ---
console = Console()
THEME = {
    "primary_fg": "#FF007F", "primary_bg": "#4D0026", "secondary_fg": "#00B29A", "text": "white",
    "success": "#00D26A", "warning": "#FFD700", "error": "#FF4F4F", "dim": "grey50", "prompt": "cyan",
}
HIGHLIGHT_STYLE = Style(color=THEME["primary_fg"], bgcolor=THEME["primary_bg"], bold=True)

TMDB_BEARER = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJkZTA0YjkwNjExM2ZlMWJiNTZiZjYzMWRiYmNjNmUzZiIsIm5iZiI6MTc1ODU5NDA2OS40NzgwMDAyLCJzdWIiOiI2OGQyMDQxNTM2ZWE2OTEzNzBjZDgwY2QiLCJzY29wZXMiOlsiYXBpX3JlYWQiXSwidmVyc2lvbiI6MX0.Z0dMqssuvDrfBsjIIkl4U0OE7npl5gSD7pAavmO6NyM"
BASE_URL = "https://api.themoviedb.org/3"
SESSION = requests.Session()
SESSION.headers.update({"Authorization": f"Bearer {TMDB_BEARER}", "Accept": "application/json"})

CACHE_DIR = "."; GENRES_CACHE_FILE = os.path.join(CACHE_DIR, "genres.json"); CATALOG_CACHE_FILE = os.path.join(CACHE_DIR, "catalog.json"); CACHE_EXPIRATION_DAYS = 7

# --- Fun√ß√µes de L√≥gica ---
def _norm(s: str) -> str:
    if s is None: return ""
    return "".join(c for c in unicodedata.normalize("NFKD", str(s)).lower() if not unicodedata.combining(c)).strip()

def _tmdb_request(path, params=None, retries=3):
    wait_time = 0.25
    for _ in range(retries + 1):
        try:
            r = SESSION.get(f"{BASE_URL}{path}", params=params or {}, timeout=20);
            if r.status_code == 429: time.sleep(float(r.headers.get("Retry-After", wait_time))); wait_time=min(3.0,wait_time*1.8); continue
            r.raise_for_status(); return r.json()
        except requests.RequestException: time.sleep(wait_time); wait_time=min(3.0,wait_time*1.8)
    return {}

def _get_year(date_str):
    if not date_str: return None
    try: return int(date_str.split("-")[0])
    except (ValueError, IndexError): return None

def _is_cache_valid(filepath, days=CACHE_EXPIRATION_DAYS):
    if not os.path.exists(filepath): return False
    return (time.time() - os.path.getmtime(filepath)) < (days * 86400)

_genres_cache = None
def _get_genres_cached():
    global _genres_cache
    if _genres_cache: return _genres_cache
    if _is_cache_valid(GENRES_CACHE_FILE):
        with open(GENRES_CACHE_FILE, 'r', encoding='utf-8') as f: _genres_cache = json.load(f); return _genres_cache
    mg=_tmdb_request("/genre/movie/list",{"language":"pt-BR"}).get("genres",[]); tg=_tmdb_request("/genre/tv/list",{"language":"pt-BR"}).get("genres",[])
    genres={"movie_genres":{g["id"]:g["name"] for g in mg},"tv_genres":{g["id"]:g["name"] for g in tg}}
    with open(GENRES_CACHE_FILE, 'w', encoding='utf-8') as f: json.dump(genres,f,ensure_ascii=False,indent=2)
    _genres_cache = genres; return genres

def _discover_page(task):
    kind, g, s, d, p, lang, all_g, keywords = task; d0, d1 = d; params={"language":lang,"sort_by":s,"page":p,"include_adult":"false","vote_count.gte":100}
    if keywords: params["with_keywords"] = keywords
    data = _tmdb_request(f"/discover/{kind}", params)
    g_map = all_g["movie_genres"] if kind == "movie" else all_g["tv_genres"]
    dk, tk, otk = ("release_date","title","original_title") if kind == "movie" else ("first_air_date","name","original_name")
    res=[]
    for it in data.get("results",[]):
        g_list=[g_map.get(gid) for gid in it.get("genre_ids",[]) if g_map.get(gid)]
        res.append({"id":it["id"],"type":kind,"title":it.get(tk) or it.get(otk) or "","genres":"|".join(g_list),"year":_get_year(it.get(dk)),"runtime":None,"vote_avg":float(it.get("vote_average",0.0)),"vote_cnt":int(it.get("vote_count",0)),"popularity":float(it.get("popularity",0.0))})
    return res, (data.get("page",0) < data.get("total_pages",0))

def _fetch_live_catalog(target, lang, workers):
    g=_get_genres_cached()
    m_ids_map={name:gid for gid,name in g["movie_genres"].items()}; t_ids_map={name:gid for gid,name in g["tv_genres"].items()}
    m_ids=list(m_ids_map.values()); t_ids=list(t_ids_map.values())
    series_priority_tasks = []
    anime_keyword = "210024"
    anime_genres = [t_ids_map.get("Anima√ß√£o"), t_ids_map.get("A√ß√£o e Aventura"), t_ids_map.get("Sci-Fi & Fantasy")]
    anime_genres_clean = [gid for gid in anime_genres if gid]
    if anime_genres_clean:
        for sort_key in ["popularity.desc", "vote_average.desc"]:
            for page in range(1, 11): series_priority_tasks.append(("tv", anime_genres_clean, sort_key, ("2000-01-01", "2025-12-31"), page, lang, g, anime_keyword))
    for sort_key in ["popularity.desc", "vote_average.desc"]:
        for genre_chunk in [t_ids[i:i+2] for i in range(0,len(t_ids),2)]:
            for page in range(1, 4): series_priority_tasks.append(("tv", genre_chunk, sort_key, ("2010-01-01", "2025-12-31"), page, lang, g, None))
    general_tasks = []
    decades=[("1990-01-01","1999-12-31"),("2000-01-01","2009-12-31"),("2010-01-01","2019-12-31"),("2020-01-01","2025-12-31")]; sorts=["vote_average.desc","popularity.desc"]
    for d in decades:
        for s in sorts:
            shuffled_m_ids = random.sample(m_ids, len(m_ids)); shuffled_t_ids = random.sample(t_ids, len(t_ids))
            for chunk in [shuffled_m_ids[i:i+2] for i in range(0,len(shuffled_m_ids),2)]: general_tasks.append(("movie",chunk,s,d,1,lang,g,None))
            for chunk in [shuffled_t_ids[i:i+2] for i in range(0,len(shuffled_t_ids),2)]: general_tasks.append(("tv",chunk,s,d,1,lang,g,None))
    random.shuffle(series_priority_tasks); random.shuffle(general_tasks)
    tasks=deque(series_priority_tasks + general_tasks)
    catalog,seen_ids=[],set()
    with Progress(SpinnerColumn(style=THEME["primary_fg"]),TextColumn("[progress.description]{task.description}"),BarColumn(bar_width=None),TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),TextColumn("‚Ä¢ {task.completed}/{task.total} t√≠tulos"),TimeElapsedColumn(),console=console,transient=True) as prog:
        task_id=prog.add_task(f"[{THEME['dim']}]Buscando na API TMDB...[/]", total=target)
        with cf.ThreadPoolExecutor(max_workers=workers) as ex:
            futures={ex.submit(_discover_page,tasks.popleft()):tasks[0] for _ in range(min(len(tasks),workers*2))}
            while futures and len(catalog)<target:
                done,_=cf.wait(futures,return_when=cf.FIRST_COMPLETED)
                for fut in done:
                    orig_task=futures.pop(fut)
                    try:
                        batch,has_more=fut.result(); added=0
                        for item in batch:
                            key=(item["type"],item["id"]);
                            if key not in seen_ids: seen_ids.add(key); catalog.append(item); added+=1
                        prog.update(task_id,advance=added)
                        (kind,gn,s,d,p,ln,gs,kw)=orig_task
                        if has_more and added > 0 and p < 15 and len(catalog) < target:
                            tasks.append((kind,gn,s,d,p+1,ln,gs,kw))
                    except Exception: pass
                    if tasks and len(futures)<workers*2: futures[ex.submit(_discover_page,tasks.popleft())]=tasks[0]
    return catalog[:target]

def build_catalog_cached(target, force_rebuild):
    if not force_rebuild and _is_cache_valid(CATALOG_CACHE_FILE):
        with console.status(f"[{THEME['dim']}]Carregando cat√°logo local...[/]", spinner="dots"):
            with open(CATALOG_CACHE_FILE, 'r', encoding='utf-8') as f: catalog = json.load(f)
        console.print(f"[bold {THEME['success']}]‚úì[/] Cat√°logo pronto com {len(catalog)} t√≠tulos.")
        return catalog
    console.print(f"[bold {THEME['warning']}]![/] Cache do cat√°logo inv√°lido. Buscando da API (pode levar alguns minutos)...")
    catalog = _fetch_live_catalog(target,"pt-BR",10)
    with open(CATALOG_CACHE_FILE, 'w', encoding='utf-8') as f: json.dump(catalog,f,ensure_ascii=False)
    console.print(f"[bold {THEME['success']}]‚úì[/] Cat√°logo pronto com {len(catalog)} t√≠tulos.")
    return catalog

GEN_CANON=["A√ß√£o","Aventura","Anima√ß√£o","Com√©dia","Crime","Document√°rio","Drama","Fam√≠lia","Fantasia","Hist√≥ria","Terror","M√∫sica","Mist√©rio","Romance","Fic√ß√£o Cient√≠fica","Cinema TV","Thriller","Guerra","Faroeste"]
THEMES={"heist":["Crime","A√ß√£o"],"espacial":["Fic√ß√£o Cient√≠fica","Aventura"],"medieval":["Fantasia","Hist√≥ria"],"super-heroi":["A√ß√£o","Aventura","Fantasia"],"politica":["Drama","Thriller"],"biografia":["Drama","Hist√≥ria"],"noir":["Crime","Mist√©rio"],"musical":["M√∫sica","Romance"],"suspense":["Thriller","Mist√©rio"]}
def map_terms_to_genres(terms):
    out=set(); norm_canon=[_norm(g) for g in GEN_CANON]
    for term in terms:
        norm_term=_norm(term);
        if not norm_term: continue
        for theme_key, theme_genres in THEMES.items():
            if fuzz.partial_ratio(norm_term,theme_key)>85: out.update(theme_genres)
        best=process.extractOne(norm_term,norm_canon,scorer=fuzz.token_set_ratio)
        if best and best[1]>75: out.add(GEN_CANON[best[2]])
    return list(out)

def get_duration_score(pref, runtime):
    if runtime is None: return 0.5
    t=_norm(pref or "");
    if "curt" in t: return max(0.0,1-abs(runtime-90)/90)
    if "medi" in t: return max(0.0,1-abs(runtime-120)/60)
    if "long" in t: return max(0.0,1-abs(runtime-180)/180)
    return 0.5

TYPE_MATCH_STRONG_BONUS = 60
def score_item(item, prefs):
    s=0.0; i_g_norm=_norm(item["genres"])
    if prefs["type"] and prefs["type"] == item["type"]: s += TYPE_MATCH_STRONG_BONUS
    for g_norm in prefs["inc_norm"]:
        if g_norm in i_g_norm: s+=15
    for g_norm in prefs["exc_norm"]:
        if g_norm in i_g_norm: s-=25
    s+=10*get_duration_score(prefs["dur"],item.get("runtime"))
    q=(item["vote_avg"]/10.0)*(min(1.0,item["vote_cnt"]/5000.0)); p=min(1.0,item["popularity"]/1000.0)
    s+=prefs["w_rating"]*q*12; s+=prefs["w_pop"]*p*12
    y=item.get("year") or 2000
    if "classic_focus" in prefs and prefs["classic_focus"]: s+=max(0, (2000-y)/10)
    elif prefs["prefer_new"]: s+=max(0,(y-2000)/3)
    else: s-=max(0,(y-2010)/4)
    return s

def _fetch_details_concurrent(items_to_detail: List[Dict]) -> List[Dict]:
    def fetch_one(item):
        path = f"/{item['type']}/{item['id']}"
        data = _tmdb_request(path, params={"language": "pt-BR", "append_to_response": "credits"})
        if not data: return item
        if item["type"] == "movie": item["runtime"] = data.get("runtime")
        else: r = data.get("episode_run_time", []); item["runtime"] = int(sum(r) / len(r)) if r else None
        item["synopsis"] = data.get("overview", f"[{THEME['dim']}]Sinopse n√£o dispon√≠vel.[/{THEME['dim']}]")
        if item["type"] == "movie":
            directors = [c["name"] for c in data.get("credits", {}).get("crew", []) if c.get("job") == "Director"]
            item["director"] = ", ".join(directors) if directors else f"[{THEME['dim']}]N/A[/]"
        else:
            creators = [c["name"] for c in data.get("created_by", [])]
            item["director"] = ", ".join(creators) if creators else f"[{THEME['dim']}]N/A[/]"
        cast = [c["name"] for c in data.get("credits", {}).get("cast", [])[:4]]
        item["cast"] = ", ".join(cast) if cast else f"[{THEME['dim']}]N/A[/]"
        return item
    with cf.ThreadPoolExecutor(max_workers=4) as ex:
        return list(ex.map(fetch_one, items_to_detail))

# --- IA DE COMENT√ÅRIOS LOCAL EXPANDIDA ---
COMMENT_TEMPLATES = {
    "A√ß√£o": ["Prepare-se para sequ√™ncias de tirar o f√¥lego e pura octanagem.", "Um prato cheio para quem gosta de adrenalina e explos√µes."],
    "Aventura": ["Uma jornada √©pica para lugares fant√°sticos que vai despertar seu esp√≠rito explorador.", "Ideal para quem busca uma grande escapada no sof√°."],
    "Com√©dia": ["Gargalhadas garantidas do in√≠cio ao fim.", "Humor inteligente que vai te fazer pensar e rir ao mesmo tempo."],
    "Drama": ["Uma hist√≥ria emocionante que vai te prender na cadeira.", "Prepare os len√ßos, pois o roteiro √© profundo e as atua√ß√µes s√£o marcantes."],
    "Fic√ß√£o Cient√≠fica": ["Uma viagem a um universo fascinante que expande a mente.", "Um espet√°culo visual que redefine o que voc√™ espera do g√™nero."],
    "Terror": ["Para assistir com as luzes acesas e a porta trancada.", "Tens√£o constru√≠da com maestria, muito al√©m de simples sustos."],
    "Romance": ["Uma hist√≥ria de amor cativante para aquecer o cora√ß√£o.", "Mostra que o amor pode ser complicado, mas sempre vale a pena."],
    "Mist√©rio": ["Voc√™ vai roer as unhas tentando desvendar este quebra-cabe√ßa.", "Uma trama cheia de reviravoltas que te engana at√© o √∫ltimo minuto."],
    "Anima√ß√£o": ["Uma anima√ß√£o deslumbrante, tanto para crian√ßas quanto para adultos.", "Visualmente incr√≠vel e com uma mensagem poderosa e universal."],
    "default": ["Uma obra interessante que merece uma chance.", "Pode ser uma boa surpresa para a sua noite de cinema."]
}
QUALIFIER_PHRASES = {
    "acclaimed": ["Aclamado pela cr√≠tica, esta √© uma escolha de peso.", "Com notas alt√≠ssimas, √© praticamente uma aposta certa."],
    "popular": ["O t√≠tulo do momento que est√° na boca de todo mundo.", "Um fen√¥meno de p√∫blico, descubra o porqu√™ do sucesso."],
    "underrated": ["Uma joia subestimada que merece muito mais aten√ß√£o.", "Pode n√£o ser um blockbuster, mas com certeza vai te surpreender."],
    "classic": ["Um verdadeiro cl√°ssico que continua relevante e inspirador.", "Uma viagem nost√°lgica a uma era de ouro do cinema/TV."]
}

def generate_ai_comment_local(item: Dict) -> str:
    genres = item.get("genres", "").split("|")
    primary_genre = genres[0] if genres else "default"

    comment_parts = []
    templates = COMMENT_TEMPLATES.get(primary_genre, COMMENT_TEMPLATES["default"])
    comment_parts.append(random.choice(templates))

    if item.get("vote_avg", 0) >= 8.2:
        comment_parts.append(random.choice(QUALIFIER_PHRASES["acclaimed"]))
    elif (item.get("year", 2025) or 2025) < 2000:
        comment_parts.append(random.choice(QUALIFIER_PHRASES["classic"]))
    elif item.get("popularity", 0) > 1000:
        comment_parts.append(random.choice(QUALIFIER_PHRASES["popular"]))
    elif 6.8 <= item.get("vote_avg", 0) < 7.8:
        comment_parts.append(random.choice(QUALIFIER_PHRASES["underrated"]))

    return " ".join(comment_parts)


# --- Componentes de UI e Intera√ß√£o ---
def banner():
    console.print(Panel(Text("üé¨ CineAI", style=HIGHLIGHT_STYLE, justify="center"),
                            box=MINIMAL, padding=(1, 0)))
    console.print(Text("As melhores sugest√µes para voc√™!", style=THEME["dim"], justify="center"))

def get_match_color(score_pct: float) -> Style:
    if score_pct > 92: return Style(color="#00FF7F")
    if score_pct > 80: return Style(color="#ADFF2F")
    if score_pct > 65: return Style(color=THEME["warning"])
    return Style(color="#FFA07A")

def show_results(scored_items: List[tuple], top_n=3):
    if not scored_items: return
    scores = [s for s, _ in scored_items]; min_s, max_s = min(scores), max(scores)

    summary_table = Table(title=Text("Resumo das Recomenda√ß√µes", style=HIGHLIGHT_STYLE),
                  header_style=f"bold {THEME['text']}", box=MINIMAL, border_style=THEME["dim"])
    summary_table.add_column("Compatibilidade", justify="center", width=15); summary_table.add_column("Tipo", width=5); summary_table.add_column("T√≠tulo", min_width=20, overflow="fold")
    summary_table.add_column("Ano", width=4); summary_table.add_column("G√™neros", overflow="fold"); summary_table.add_column("üïí", justify="center", width=7); summary_table.add_column("‚≠ê", justify="center", width=5)

    for score, item in scored_items[:top_n]:
        pct = 40 + (score - min_s) / (max_s - min_s + 1e-6) * 59 if max_s > min_s else 95.0
        pct_text = Text(f"{pct:.1f}%", style=get_match_color(pct))
        tipo_style=THEME["success"] if item["type"]=="movie" else THEME["secondary_fg"]
        tipo=f"[bold {tipo_style}]FILME[/]" if item["type"]=="movie" else f"[bold {tipo_style}]S√âRIE[/]"
        runtime=f"{item.get('runtime')}m" if item.get('runtime') else f"[{THEME['dim']}]N/A[/]"
        nota_style = get_match_color(item['vote_avg'] * 10)
        summary_table.add_row(pct_text, tipo, Text(item["title"], style=THEME["text"]), str(item.get("year","")),
                      Text(item["genres"].replace("|",", "), style=THEME["dim"]), runtime, Text(f"{item['vote_avg']:.1f}", style=nota_style))
    console.print(summary_table)

    console.print(Rule(style=THEME["dim"], characters="¬∑"))

    for i, (_, item) in enumerate(scored_items[:top_n], 1):
        title = Text.from_markup(f"[bold]#{i} {item['title']}[/] [{THEME['dim']}]({item.get('year', 'N/A')})[/]")
        synopsis = Text(f"\n  {item.get('synopsis', 'N/A')}\n", style=THEME["dim"], justify="full")

        details_grid = Table.grid(padding=(0, 1)); details_grid.add_column(width=10); details_grid.add_column()
        director_label = 'Diretor:' if item['type'] == 'movie' else 'Criador:'
        details_grid.add_row(f"[bold {THEME['prompt']}]{director_label}[/]", Text(item.get('director', 'N/A'), style=THEME['text']))
        details_grid.add_row(f"[bold {THEME['prompt']}]Elenco:[/]", Text(item.get('cast', 'N/A'), style=THEME['text']))

        # CORRE√á√ÉO AQUI
        ai_comment = Text.from_markup(f"\n[bold {THEME['primary_fg']}]üí¨ Coment√°rio do CineAI:[/]\n[i]{item.get('ai_comment', '...')}[/i]")

        render_group = Group(title, synopsis, details_grid, ai_comment)
        console.print(render_group)
        if i < top_n:
             console.print(Rule(style=THEME["dim"], characters="¬∑"))

def _create_prompt_grid(prompt_renderable, explanation_text):
    grid = Table.grid(expand=True); grid.add_column(); grid.add_column(justify="right")
    grid.add_row(prompt_renderable, Text(explanation_text, style=THEME["dim"]))
    console.print(grid)

def fuzzy_prompt(prompt_text, choices, default=None, threshold=70, explanation=""):
    prompt_choices_str=" / ".join(f"[b]{c}[/b]" for c in choices)
    prompt_render = Text.from_markup(f"[bold {THEME['prompt']}]‚ùØ {prompt_text}[/] ({prompt_choices_str})")
    _create_prompt_grid(prompt_render, explanation)
    while True:
        user_input = Prompt.ask("  ‚ï∞‚îÄ> ", default=default)
        if not user_input: user_input=default
        norm_input=_norm(user_input); norm_choices=[_norm(c) for c in choices]
        best=process.extractOne(norm_input,norm_choices,scorer=fuzz.token_set_ratio)
        if best and best[1]>=threshold: return choices[best[2]]
        else: console.print(f"  [{THEME['error']}]Op√ß√£o '[white]{user_input}[/white]' n√£o reconhecida.[/{THEME['error']}]")

def ask_preferences_panel():
    console.print(Text("\nSuas Prefer√™ncias", style=HIGHLIGHT_STYLE, justify="center"))
    console.print(Text("Responda √†s perguntas para calibrar as recomenda√ß√µes.", style=THEME['dim'], justify="center"))
    console.print("")
    tipo_map={"Filme":"movie","S√©rie":"tv","Tanto faz":""}; foco_map={"Nota":(1.0,0.4),"Popularidade":(0.4,1.0),"Equil√≠brio":(0.8,0.8)}
    tipo=fuzzy_prompt("Tipo de M√≠dia", choices=list(tipo_map.keys()), default="Tanto faz", explanation="Default: 'Tanto faz'")
    foco=fuzzy_prompt("Foco Principal", choices=list(foco_map.keys()), default="Equil√≠brio", explanation="Default: 'Equil√≠brio'")

    _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]‚ùØ G√™neros/temas que voc√™ curte[/]"), "Separe por v√≠rgulas. Ex: A√ß√£o, Com√©dia.")
    inc_raw=Prompt.ask("  ‚ï∞‚îÄ> ",default="")

    _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]‚ùØ Algo para evitar[/]"), "G√™neros que voc√™ N√ÉO gosta.")
    exc_raw=Prompt.ask("  ‚ï∞‚îÄ> ",default="")

    _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]‚ùØ Dura√ß√£o preferida (curta, m√©dia, longa)[/]"), "Deixe em branco para n√£o ter prefer√™ncia.")
    dur=Prompt.ask("  ‚ï∞‚îÄ> ",default="")

    prefer_new = Confirm.ask(Text.from_markup(f"[bold {THEME['prompt']}]‚ùØ Priorizar lan√ßamentos?[/]"), default=False)

    w_r,w_p=foco_map[foco]; inc_g=map_terms_to_genres(re.split(r"[,;\|/]+",inc_raw)); exc_g=map_terms_to_genres(re.split(r"[,;\|/]+",exc_raw))
    console.print(f"\n[{THEME['dim']}]G√™neros mapeados: Incluindo [bold {THEME['warning']}]{inc_g or 'Nenhum'}[/] | Excluindo [bold {THEME['error']}]{exc_g or 'Nenhum'}[/][/{THEME['dim']}]")

    return {"type":tipo_map[tipo],"inc":inc_g,"exc":exc_g,"inc_norm":[_norm(g) for g in inc_g],"exc_norm":[_norm(g) for g in exc_g],
            "dur":dur,"prefer_new":prefer_new,"w_rating":w_r,"w_pop":w_p}

def refine_preferences(prefs):
    console.print(Text("\nRefinar Busca", style=HIGHLIGHT_STYLE, justify="center"))
    choices=["Foco em cl√°ssicos (80/90)","Apenas os mais aclamados","Algo mais 'cult' (menos popular)","Adicionar um g√™nero","Remover um g√™nero"]
    action = fuzzy_prompt("O que deseja ajustar?", choices=choices)
    if "cl√°ssicos" in action: prefs["classic_focus"]=True; prefs["prefer_new"]=False; console.print(f"[bold {THEME['success']}]‚úì[/] Foco ajustado para cl√°ssicos.")
    elif "aclamados" in action: prefs["w_rating"]=1.2; prefs["w_pop"]=0.3; console.print(f"[bold {THEME['success']}]‚úì[/] Foco ajustado para filmes aclamados.")
    elif "cult" in action: prefs["w_rating"]=0.6; prefs["w_pop"]=0.1; console.print(f"[bold {THEME['success']}]‚úì[/] Foco ajustado para t√≠tulos menos populares.")
    elif "Adicionar" in action:
        _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]Qual g√™nero para adicionar?[/]"), "")
        add_g = Prompt.ask("  ‚ï∞‚îÄ> "); g_to_add=map_terms_to_genres([add_g])
        if g_to_add: prefs["inc"]=list(set(prefs["inc"]+g_to_add)); prefs["inc_norm"]=[_norm(g) for g in prefs["inc"]]; console.print(f"[bold {THEME['success']}]‚úì[/] Adicionado: {g_to_add}")
    elif "Remover" in action:
        _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]Qual g√™nero para remover?[/]"), "")
        rem_g = Prompt.ask("  ‚ï∞‚îÄ> "); g_to_rem=map_terms_to_genres([rem_g])
        if g_to_rem:
            prefs["inc"]=[g for g in prefs["inc"] if g not in g_to_rem]; prefs["inc_norm"]=[_norm(g) for g in prefs["inc"]]
            prefs["exc"]=list(set(prefs["exc"]+g_to_rem)); prefs["exc_norm"]=[_norm(g) for g in prefs["exc"]]; console.print(f"[bold {THEME['success']}]‚úì[/] Removido/Evitado: {g_to_rem}")
    return prefs

def cli(args):
    console.clear(); banner()
    catalog = build_catalog_cached(args.target, args.rebuild)
    if not catalog: console.print(Panel(f"[{THEME['error']}]Falha ao construir o cat√°logo.[/]", box=MINIMAL, border_style=THEME['error'])); return

    console.print(Rule(style=THEME["dim"]))
    prefs = ask_preferences_panel()

    while True:
        with console.status(f"[{THEME['dim']}]üß† Calculando recomenda√ß√µes...[/]", spinner="dots"):
            scored_items = sorted([(score_item(item, prefs), item) for item in catalog], key=lambda x:x[0], reverse=True)

        items_needing_details = [item for _, item in scored_items[:3]]
        if items_needing_details:
            with console.status(f"[{THEME['dim']}]Buscando detalhes...[/]", spinner="dots"):
                _fetch_details_concurrent(items_needing_details)
            for item in items_needing_details:
                item['ai_comment'] = generate_ai_comment_local(item)

        console.print(Rule(style=THEME["dim"]))
        show_results(scored_items, top_n=3)

        console.print("")
        action = fuzzy_prompt("O que fazer agora?", choices=["Refinar Sugest√µes", "Nova Busca Completa", "Sair"], default="Refinar Sugest√µes")

        if action == "Sair": break
        elif action == "Nova Busca Completa": console.print(Rule(style=THEME["dim"])); prefs = ask_preferences_panel()
        elif action == "Refinar Sugest√µes": console.print(Rule(style=THEME["dim"])); prefs = refine_preferences(prefs)

    console.print(Panel(Text(f"üçø Bom filme/s√©rie!", style=HIGHLIGHT_STYLE), box=MINIMAL, padding=(1, 4)))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CineAI - Recomenda√ß√µes de Filmes e S√©ries")
    parser.add_argument("--target", type=int, default=2500, help="N√∫mero de t√≠tulos desejado no cat√°logo.")
    parser.add_argument("--rebuild", action="store_true", help="For√ßa a reconstru√ß√£o do cache do cat√°logo.")
    try:
        args = parser.parse_args()
    except SystemExit:
        args = parser.parse_args([])

    try:
        if not TMDB_BEARER or "eyJ" not in TMDB_BEARER:
            console.print(f"[{THEME['error']}]ERRO: A vari√°vel TMDB_BEARER n√£o √© uma chave de API v√°lida.[/{THEME['error']}]")
        else:
            cli(args)
    except KeyboardInterrupt:
        console.print(f"\n[{THEME['error']}]Encerrado pelo usu√°rio.[/{THEME['error']}]")
    except Exception as e:
        console.print_exception()