# -*- coding: utf-8 -*-
"""cineAI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13NfksvVpmojLvMcqZVVV_nZKYVNt7T00
"""

import sys, subprocess, time, re, unicodedata, random, json, os, argparse
from collections import deque
import concurrent.futures as cf
from typing import Any, Dict, List

# --- Dependências e Instalação ---
def _pip_install(p):
    try: __import__(p.split("==")[0])
    except ImportError: subprocess.check_call([sys.executable, "-m", "pip", "install", p, "-q"])

for dep in ["requests", "rapidfuzz", "rich"]: _pip_install(dep)

import requests
from rapidfuzz import fuzz, process
from rich.console import Console, Group
from rich.panel import Panel
from rich.prompt import Prompt, Confirm
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeElapsedColumn
from rich.rule import Rule
from rich.table import Table
from rich.text import Text
from rich.style import Style
from rich.box import MINIMAL

# --- Configurações Globais e Tema ---
console = Console()
THEME = {
    "primary_fg": "#FF007F", "primary_bg": "#4D0026", "secondary_fg": "#00B29A", "text": "white",
    "success": "#00D26A", "warning": "#FFD700", "error": "#FF4F4F", "dim": "grey50", "prompt": "cyan",
}
HIGHLIGHT_STYLE = Style(color=THEME["primary_fg"], bgcolor=THEME["primary_bg"], bold=True)

TMDB_BEARER = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJkZTA0YjkwNjExM2ZlMWJiNTZiZjYzMWRiYmNjNmUzZiIsIm5iZiI6MTc1ODU5NDA2OS40NzgwMDAyLCJzdWIiOiI2OGQyMDQxNTM2ZWE2OTEzNzBjZDgwY2QiLCJzY29wZXMiOlsiYXBpX3JlYWQiXSwidmVyc2lvbiI6MX0.Z0dMqssuvDrfBsjIIkl4U0OE7npl5gSD7pAavmO6NyM"
BASE_URL = "https://api.themoviedb.org/3"
SESSION = requests.Session()
SESSION.headers.update({"Authorization": f"Bearer {TMDB_BEARER}", "Accept": "application/json"})

CACHE_DIR = "."; GENRES_CACHE_FILE = os.path.join(CACHE_DIR, "genres.json"); CATALOG_CACHE_FILE = os.path.join(CACHE_DIR, "catalog.json"); CACHE_EXPIRATION_DAYS = 7

# --- Funções de Lógica ---
def _norm(s: str) -> str:
    if s is None: return ""
    return "".join(c for c in unicodedata.normalize("NFKD", str(s)).lower() if not unicodedata.combining(c)).strip()

def _tmdb_request(path, params=None, retries=3):
    wait_time = 0.25
    for _ in range(retries + 1):
        try:
            r = SESSION.get(f"{BASE_URL}{path}", params=params or {}, timeout=20);
            if r.status_code == 429: time.sleep(float(r.headers.get("Retry-After", wait_time))); wait_time=min(3.0,wait_time*1.8); continue
            r.raise_for_status(); return r.json()
        except requests.RequestException: time.sleep(wait_time); wait_time=min(3.0,wait_time*1.8)
    return {}

def _get_year(date_str):
    if not date_str: return None
    try: return int(date_str.split("-")[0])
    except (ValueError, IndexError): return None

def _is_cache_valid(filepath, days=CACHE_EXPIRATION_DAYS):
    if not os.path.exists(filepath): return False
    return (time.time() - os.path.getmtime(filepath)) < (days * 86400)

_genres_cache = None
def _get_genres_cached():
    global _genres_cache
    if _genres_cache: return _genres_cache
    if _is_cache_valid(GENRES_CACHE_FILE):
        with open(GENRES_CACHE_FILE, 'r', encoding='utf-8') as f: _genres_cache = json.load(f); return _genres_cache
    mg=_tmdb_request("/genre/movie/list",{"language":"pt-BR"}).get("genres",[]); tg=_tmdb_request("/genre/tv/list",{"language":"pt-BR"}).get("genres",[])
    genres={"movie_genres":{g["id"]:g["name"] for g in mg},"tv_genres":{g["id"]:g["name"] for g in tg}}
    with open(GENRES_CACHE_FILE, 'w', encoding='utf-8') as f: json.dump(genres,f,ensure_ascii=False,indent=2)
    _genres_cache = genres; return genres

def _discover_page(task):
    kind, g, s, d, p, lang, all_g, keywords = task; d0, d1 = d; params={"language":lang,"sort_by":s,"page":p,"include_adult":"false","vote_count.gte":100}
    if keywords: params["with_keywords"] = keywords
    data = _tmdb_request(f"/discover/{kind}", params)
    g_map = all_g["movie_genres"] if kind == "movie" else all_g["tv_genres"]
    dk, tk, otk = ("release_date","title","original_title") if kind == "movie" else ("first_air_date","name","original_name")
    res=[]
    for it in data.get("results",[]):
        g_list=[g_map.get(gid) for gid in it.get("genre_ids",[]) if g_map.get(gid)]
        res.append({"id":it["id"],"type":kind,"title":it.get(tk) or it.get(otk) or "","genres":"|".join(g_list),"year":_get_year(it.get(dk)),"runtime":None,"vote_avg":float(it.get("vote_average",0.0)),"vote_cnt":int(it.get("vote_count",0)),"popularity":float(it.get("popularity",0.0))})
    return res, (data.get("page",0) < data.get("total_pages",0))

def _fetch_live_catalog(target, lang, workers):
    g=_get_genres_cached()
    m_ids_map={name:gid for gid,name in g["movie_genres"].items()}; t_ids_map={name:gid for gid,name in g["tv_genres"].items()}
    m_ids=list(m_ids_map.values()); t_ids=list(t_ids_map.values())
    series_priority_tasks = []
    anime_keyword = "210024"
    anime_genres = [t_ids_map.get("Animação"), t_ids_map.get("Ação e Aventura"), t_ids_map.get("Sci-Fi & Fantasy")]
    anime_genres_clean = [gid for gid in anime_genres if gid]
    if anime_genres_clean:
        for sort_key in ["popularity.desc", "vote_average.desc"]:
            for page in range(1, 11): series_priority_tasks.append(("tv", anime_genres_clean, sort_key, ("2000-01-01", "2025-12-31"), page, lang, g, anime_keyword))
    for sort_key in ["popularity.desc", "vote_average.desc"]:
        for genre_chunk in [t_ids[i:i+2] for i in range(0,len(t_ids),2)]:
            for page in range(1, 4): series_priority_tasks.append(("tv", genre_chunk, sort_key, ("2010-01-01", "2025-12-31"), page, lang, g, None))
    general_tasks = []
    decades=[("1990-01-01","1999-12-31"),("2000-01-01","2009-12-31"),("2010-01-01","2019-12-31"),("2020-01-01","2025-12-31")]; sorts=["vote_average.desc","popularity.desc"]
    for d in decades:
        for s in sorts:
            shuffled_m_ids = random.sample(m_ids, len(m_ids)); shuffled_t_ids = random.sample(t_ids, len(t_ids))
            for chunk in [shuffled_m_ids[i:i+2] for i in range(0,len(shuffled_m_ids),2)]: general_tasks.append(("movie",chunk,s,d,1,lang,g,None))
            for chunk in [shuffled_t_ids[i:i+2] for i in range(0,len(shuffled_t_ids),2)]: general_tasks.append(("tv",chunk,s,d,1,lang,g,None))
    random.shuffle(series_priority_tasks); random.shuffle(general_tasks)
    tasks=deque(series_priority_tasks + general_tasks)
    catalog,seen_ids=[],set()
    with Progress(SpinnerColumn(style=THEME["primary_fg"]),TextColumn("[progress.description]{task.description}"),BarColumn(bar_width=None),TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),TextColumn("• {task.completed}/{task.total} títulos"),TimeElapsedColumn(),console=console,transient=True) as prog:
        task_id=prog.add_task(f"[{THEME['dim']}]Buscando na API TMDB...[/]", total=target)
        with cf.ThreadPoolExecutor(max_workers=workers) as ex:
            futures={ex.submit(_discover_page,tasks.popleft()):tasks[0] for _ in range(min(len(tasks),workers*2))}
            while futures and len(catalog)<target:
                done,_=cf.wait(futures,return_when=cf.FIRST_COMPLETED)
                for fut in done:
                    orig_task=futures.pop(fut)
                    try:
                        batch,has_more=fut.result(); added=0
                        for item in batch:
                            key=(item["type"],item["id"]);
                            if key not in seen_ids: seen_ids.add(key); catalog.append(item); added+=1
                        prog.update(task_id,advance=added)
                        (kind,gn,s,d,p,ln,gs,kw)=orig_task
                        if has_more and added > 0 and p < 15 and len(catalog) < target:
                            tasks.append((kind,gn,s,d,p+1,ln,gs,kw))
                    except Exception: pass
                    if tasks and len(futures)<workers*2: futures[ex.submit(_discover_page,tasks.popleft())]=tasks[0]
    return catalog[:target]

def build_catalog_cached(target, force_rebuild):
    if not force_rebuild and _is_cache_valid(CATALOG_CACHE_FILE):
        with console.status(f"[{THEME['dim']}]Carregando catálogo local...[/]", spinner="dots"):
            with open(CATALOG_CACHE_FILE, 'r', encoding='utf-8') as f: catalog = json.load(f)
        console.print(f"[bold {THEME['success']}]✓[/] Catálogo pronto com {len(catalog)} títulos.")
        return catalog
    console.print(f"[bold {THEME['warning']}]![/] Cache do catálogo inválido. Buscando da API (pode levar alguns minutos)...")
    catalog = _fetch_live_catalog(target,"pt-BR",10)
    with open(CATALOG_CACHE_FILE, 'w', encoding='utf-8') as f: json.dump(catalog,f,ensure_ascii=False)
    console.print(f"[bold {THEME['success']}]✓[/] Catálogo pronto com {len(catalog)} títulos.")
    return catalog

GEN_CANON=["Ação","Aventura","Animação","Comédia","Crime","Documentário","Drama","Família","Fantasia","História","Terror","Música","Mistério","Romance","Ficção Científica","Cinema TV","Thriller","Guerra","Faroeste"]
THEMES={"heist":["Crime","Ação"],"espacial":["Ficção Científica","Aventura"],"medieval":["Fantasia","História"],"super-heroi":["Ação","Aventura","Fantasia"],"politica":["Drama","Thriller"],"biografia":["Drama","História"],"noir":["Crime","Mistério"],"musical":["Música","Romance"],"suspense":["Thriller","Mistério"]}
def map_terms_to_genres(terms):
    out=set(); norm_canon=[_norm(g) for g in GEN_CANON]
    for term in terms:
        norm_term=_norm(term);
        if not norm_term: continue
        for theme_key, theme_genres in THEMES.items():
            if fuzz.partial_ratio(norm_term,theme_key)>85: out.update(theme_genres)
        best=process.extractOne(norm_term,norm_canon,scorer=fuzz.token_set_ratio)
        if best and best[1]>75: out.add(GEN_CANON[best[2]])
    return list(out)

def get_duration_score(pref, runtime):
    if runtime is None: return 0.5
    t=_norm(pref or "");
    if "curt" in t: return max(0.0,1-abs(runtime-90)/90)
    if "medi" in t: return max(0.0,1-abs(runtime-120)/60)
    if "long" in t: return max(0.0,1-abs(runtime-180)/180)
    return 0.5

TYPE_MATCH_STRONG_BONUS = 60
def score_item(item, prefs):
    s=0.0; i_g_norm=_norm(item["genres"])
    if prefs["type"] and prefs["type"] == item["type"]: s += TYPE_MATCH_STRONG_BONUS
    for g_norm in prefs["inc_norm"]:
        if g_norm in i_g_norm: s+=15
    for g_norm in prefs["exc_norm"]:
        if g_norm in i_g_norm: s-=25
    s+=10*get_duration_score(prefs["dur"],item.get("runtime"))
    q=(item["vote_avg"]/10.0)*(min(1.0,item["vote_cnt"]/5000.0)); p=min(1.0,item["popularity"]/1000.0)
    s+=prefs["w_rating"]*q*12; s+=prefs["w_pop"]*p*12
    y=item.get("year") or 2000
    if "classic_focus" in prefs and prefs["classic_focus"]: s+=max(0, (2000-y)/10)
    elif prefs["prefer_new"]: s+=max(0,(y-2000)/3)
    else: s-=max(0,(y-2010)/4)
    return s

def _fetch_details_concurrent(items_to_detail: List[Dict]) -> List[Dict]:
    def fetch_one(item):
        path = f"/{item['type']}/{item['id']}"
        data = _tmdb_request(path, params={"language": "pt-BR", "append_to_response": "credits"})
        if not data: return item
        if item["type"] == "movie": item["runtime"] = data.get("runtime")
        else: r = data.get("episode_run_time", []); item["runtime"] = int(sum(r) / len(r)) if r else None
        item["synopsis"] = data.get("overview", f"[{THEME['dim']}]Sinopse não disponível.[/{THEME['dim']}]")
        if item["type"] == "movie":
            directors = [c["name"] for c in data.get("credits", {}).get("crew", []) if c.get("job") == "Director"]
            item["director"] = ", ".join(directors) if directors else f"[{THEME['dim']}]N/A[/]"
        else:
            creators = [c["name"] for c in data.get("created_by", [])]
            item["director"] = ", ".join(creators) if creators else f"[{THEME['dim']}]N/A[/]"
        cast = [c["name"] for c in data.get("credits", {}).get("cast", [])[:4]]
        item["cast"] = ", ".join(cast) if cast else f"[{THEME['dim']}]N/A[/]"
        return item
    with cf.ThreadPoolExecutor(max_workers=4) as ex:
        return list(ex.map(fetch_one, items_to_detail))

# --- IA DE COMENTÁRIOS LOCAL EXPANDIDA ---
COMMENT_TEMPLATES = {
    "Ação": ["Prepare-se para sequências de tirar o fôlego e pura octanagem.", "Um prato cheio para quem gosta de adrenalina e explosões."],
    "Aventura": ["Uma jornada épica para lugares fantásticos que vai despertar seu espírito explorador.", "Ideal para quem busca uma grande escapada no sofá."],
    "Comédia": ["Gargalhadas garantidas do início ao fim.", "Humor inteligente que vai te fazer pensar e rir ao mesmo tempo."],
    "Drama": ["Uma história emocionante que vai te prender na cadeira.", "Prepare os lenços, pois o roteiro é profundo e as atuações são marcantes."],
    "Ficção Científica": ["Uma viagem a um universo fascinante que expande a mente.", "Um espetáculo visual que redefine o que você espera do gênero."],
    "Terror": ["Para assistir com as luzes acesas e a porta trancada.", "Tensão construída com maestria, muito além de simples sustos."],
    "Romance": ["Uma história de amor cativante para aquecer o coração.", "Mostra que o amor pode ser complicado, mas sempre vale a pena."],
    "Mistério": ["Você vai roer as unhas tentando desvendar este quebra-cabeça.", "Uma trama cheia de reviravoltas que te engana até o último minuto."],
    "Animação": ["Uma animação deslumbrante, tanto para crianças quanto para adultos.", "Visualmente incrível e com uma mensagem poderosa e universal."],
    "default": ["Uma obra interessante que merece uma chance.", "Pode ser uma boa surpresa para a sua noite de cinema."]
}
QUALIFIER_PHRASES = {
    "acclaimed": ["Aclamado pela crítica, esta é uma escolha de peso.", "Com notas altíssimas, é praticamente uma aposta certa."],
    "popular": ["O título do momento que está na boca de todo mundo.", "Um fenômeno de público, descubra o porquê do sucesso."],
    "underrated": ["Uma joia subestimada que merece muito mais atenção.", "Pode não ser um blockbuster, mas com certeza vai te surpreender."],
    "classic": ["Um verdadeiro clássico que continua relevante e inspirador.", "Uma viagem nostálgica a uma era de ouro do cinema/TV."]
}

def generate_ai_comment_local(item: Dict) -> str:
    genres = item.get("genres", "").split("|")
    primary_genre = genres[0] if genres else "default"

    comment_parts = []
    templates = COMMENT_TEMPLATES.get(primary_genre, COMMENT_TEMPLATES["default"])
    comment_parts.append(random.choice(templates))

    if item.get("vote_avg", 0) >= 8.2:
        comment_parts.append(random.choice(QUALIFIER_PHRASES["acclaimed"]))
    elif (item.get("year", 2025) or 2025) < 2000:
        comment_parts.append(random.choice(QUALIFIER_PHRASES["classic"]))
    elif item.get("popularity", 0) > 1000:
        comment_parts.append(random.choice(QUALIFIER_PHRASES["popular"]))
    elif 6.8 <= item.get("vote_avg", 0) < 7.8:
        comment_parts.append(random.choice(QUALIFIER_PHRASES["underrated"]))

    return " ".join(comment_parts)


# --- Componentes de UI e Interação ---
def banner():
    console.print(Panel(Text("🎬 CineAI", style=HIGHLIGHT_STYLE, justify="center"),
                            box=MINIMAL, padding=(1, 0)))
    console.print(Text("As melhores sugestões para você!", style=THEME["dim"], justify="center"))

def get_match_color(score_pct: float) -> Style:
    if score_pct > 92: return Style(color="#00FF7F")
    if score_pct > 80: return Style(color="#ADFF2F")
    if score_pct > 65: return Style(color=THEME["warning"])
    return Style(color="#FFA07A")

def show_results(scored_items: List[tuple], top_n=3):
    if not scored_items: return
    scores = [s for s, _ in scored_items]; min_s, max_s = min(scores), max(scores)

    summary_table = Table(title=Text("Resumo das Recomendações", style=HIGHLIGHT_STYLE),
                  header_style=f"bold {THEME['text']}", box=MINIMAL, border_style=THEME["dim"])
    summary_table.add_column("Compatibilidade", justify="center", width=15); summary_table.add_column("Tipo", width=5); summary_table.add_column("Título", min_width=20, overflow="fold")
    summary_table.add_column("Ano", width=4); summary_table.add_column("Gêneros", overflow="fold"); summary_table.add_column("🕒", justify="center", width=7); summary_table.add_column("⭐", justify="center", width=5)

    for score, item in scored_items[:top_n]:
        pct = 40 + (score - min_s) / (max_s - min_s + 1e-6) * 59 if max_s > min_s else 95.0
        pct_text = Text(f"{pct:.1f}%", style=get_match_color(pct))
        tipo_style=THEME["success"] if item["type"]=="movie" else THEME["secondary_fg"]
        tipo=f"[bold {tipo_style}]FILME[/]" if item["type"]=="movie" else f"[bold {tipo_style}]SÉRIE[/]"
        runtime=f"{item.get('runtime')}m" if item.get('runtime') else f"[{THEME['dim']}]N/A[/]"
        nota_style = get_match_color(item['vote_avg'] * 10)
        summary_table.add_row(pct_text, tipo, Text(item["title"], style=THEME["text"]), str(item.get("year","")),
                      Text(item["genres"].replace("|",", "), style=THEME["dim"]), runtime, Text(f"{item['vote_avg']:.1f}", style=nota_style))
    console.print(summary_table)

    console.print(Rule(style=THEME["dim"], characters="·"))

    for i, (_, item) in enumerate(scored_items[:top_n], 1):
        title = Text.from_markup(f"[bold]#{i} {item['title']}[/] [{THEME['dim']}]({item.get('year', 'N/A')})[/]")
        synopsis = Text(f"\n  {item.get('synopsis', 'N/A')}\n", style=THEME["dim"], justify="full")

        details_grid = Table.grid(padding=(0, 1)); details_grid.add_column(width=10); details_grid.add_column()
        director_label = 'Diretor:' if item['type'] == 'movie' else 'Criador:'
        details_grid.add_row(f"[bold {THEME['prompt']}]{director_label}[/]", Text(item.get('director', 'N/A'), style=THEME['text']))
        details_grid.add_row(f"[bold {THEME['prompt']}]Elenco:[/]", Text(item.get('cast', 'N/A'), style=THEME['text']))

        # CORREÇÃO AQUI
        ai_comment = Text.from_markup(f"\n[bold {THEME['primary_fg']}]💬 Comentário do CineAI:[/]\n[i]{item.get('ai_comment', '...')}[/i]")

        render_group = Group(title, synopsis, details_grid, ai_comment)
        console.print(render_group)
        if i < top_n:
             console.print(Rule(style=THEME["dim"], characters="·"))

def _create_prompt_grid(prompt_renderable, explanation_text):
    grid = Table.grid(expand=True); grid.add_column(); grid.add_column(justify="right")
    grid.add_row(prompt_renderable, Text(explanation_text, style=THEME["dim"]))
    console.print(grid)

def fuzzy_prompt(prompt_text, choices, default=None, threshold=70, explanation=""):
    prompt_choices_str=" / ".join(f"[b]{c}[/b]" for c in choices)
    prompt_render = Text.from_markup(f"[bold {THEME['prompt']}]❯ {prompt_text}[/] ({prompt_choices_str})")
    _create_prompt_grid(prompt_render, explanation)
    while True:
        user_input = Prompt.ask("  ╰─> ", default=default)
        if not user_input: user_input=default
        norm_input=_norm(user_input); norm_choices=[_norm(c) for c in choices]
        best=process.extractOne(norm_input,norm_choices,scorer=fuzz.token_set_ratio)
        if best and best[1]>=threshold: return choices[best[2]]
        else: console.print(f"  [{THEME['error']}]Opção '[white]{user_input}[/white]' não reconhecida.[/{THEME['error']}]")

def ask_preferences_panel():
    console.print(Text("\nSuas Preferências", style=HIGHLIGHT_STYLE, justify="center"))
    console.print(Text("Responda às perguntas para calibrar as recomendações.", style=THEME['dim'], justify="center"))
    console.print("")
    tipo_map={"Filme":"movie","Série":"tv","Tanto faz":""}; foco_map={"Nota":(1.0,0.4),"Popularidade":(0.4,1.0),"Equilíbrio":(0.8,0.8)}
    tipo=fuzzy_prompt("Tipo de Mídia", choices=list(tipo_map.keys()), default="Tanto faz", explanation="Default: 'Tanto faz'")
    foco=fuzzy_prompt("Foco Principal", choices=list(foco_map.keys()), default="Equilíbrio", explanation="Default: 'Equilíbrio'")

    _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]❯ Gêneros/temas que você curte[/]"), "Separe por vírgulas. Ex: Ação, Comédia.")
    inc_raw=Prompt.ask("  ╰─> ",default="")

    _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]❯ Algo para evitar[/]"), "Gêneros que você NÃO gosta.")
    exc_raw=Prompt.ask("  ╰─> ",default="")

    _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]❯ Duração preferida (curta, média, longa)[/]"), "Deixe em branco para não ter preferência.")
    dur=Prompt.ask("  ╰─> ",default="")

    prefer_new = Confirm.ask(Text.from_markup(f"[bold {THEME['prompt']}]❯ Priorizar lançamentos?[/]"), default=False)

    w_r,w_p=foco_map[foco]; inc_g=map_terms_to_genres(re.split(r"[,;\|/]+",inc_raw)); exc_g=map_terms_to_genres(re.split(r"[,;\|/]+",exc_raw))
    console.print(f"\n[{THEME['dim']}]Gêneros mapeados: Incluindo [bold {THEME['warning']}]{inc_g or 'Nenhum'}[/] | Excluindo [bold {THEME['error']}]{exc_g or 'Nenhum'}[/][/{THEME['dim']}]")

    return {"type":tipo_map[tipo],"inc":inc_g,"exc":exc_g,"inc_norm":[_norm(g) for g in inc_g],"exc_norm":[_norm(g) for g in exc_g],
            "dur":dur,"prefer_new":prefer_new,"w_rating":w_r,"w_pop":w_p}

def refine_preferences(prefs):
    console.print(Text("\nRefinar Busca", style=HIGHLIGHT_STYLE, justify="center"))
    choices=["Foco em clássicos (80/90)","Apenas os mais aclamados","Algo mais 'cult' (menos popular)","Adicionar um gênero","Remover um gênero"]
    action = fuzzy_prompt("O que deseja ajustar?", choices=choices)
    if "clássicos" in action: prefs["classic_focus"]=True; prefs["prefer_new"]=False; console.print(f"[bold {THEME['success']}]✓[/] Foco ajustado para clássicos.")
    elif "aclamados" in action: prefs["w_rating"]=1.2; prefs["w_pop"]=0.3; console.print(f"[bold {THEME['success']}]✓[/] Foco ajustado para filmes aclamados.")
    elif "cult" in action: prefs["w_rating"]=0.6; prefs["w_pop"]=0.1; console.print(f"[bold {THEME['success']}]✓[/] Foco ajustado para títulos menos populares.")
    elif "Adicionar" in action:
        _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]Qual gênero para adicionar?[/]"), "")
        add_g = Prompt.ask("  ╰─> "); g_to_add=map_terms_to_genres([add_g])
        if g_to_add: prefs["inc"]=list(set(prefs["inc"]+g_to_add)); prefs["inc_norm"]=[_norm(g) for g in prefs["inc"]]; console.print(f"[bold {THEME['success']}]✓[/] Adicionado: {g_to_add}")
    elif "Remover" in action:
        _create_prompt_grid(Text.from_markup(f"[bold {THEME['prompt']}]Qual gênero para remover?[/]"), "")
        rem_g = Prompt.ask("  ╰─> "); g_to_rem=map_terms_to_genres([rem_g])
        if g_to_rem:
            prefs["inc"]=[g for g in prefs["inc"] if g not in g_to_rem]; prefs["inc_norm"]=[_norm(g) for g in prefs["inc"]]
            prefs["exc"]=list(set(prefs["exc"]+g_to_rem)); prefs["exc_norm"]=[_norm(g) for g in prefs["exc"]]; console.print(f"[bold {THEME['success']}]✓[/] Removido/Evitado: {g_to_rem}")
    return prefs

def cli(args):
    console.clear(); banner()
    catalog = build_catalog_cached(args.target, args.rebuild)
    if not catalog: console.print(Panel(f"[{THEME['error']}]Falha ao construir o catálogo.[/]", box=MINIMAL, border_style=THEME['error'])); return

    console.print(Rule(style=THEME["dim"]))
    prefs = ask_preferences_panel()

    while True:
        with console.status(f"[{THEME['dim']}]🧠 Calculando recomendações...[/]", spinner="dots"):
            scored_items = sorted([(score_item(item, prefs), item) for item in catalog], key=lambda x:x[0], reverse=True)

        items_needing_details = [item for _, item in scored_items[:3]]
        if items_needing_details:
            with console.status(f"[{THEME['dim']}]Buscando detalhes...[/]", spinner="dots"):
                _fetch_details_concurrent(items_needing_details)
            for item in items_needing_details:
                item['ai_comment'] = generate_ai_comment_local(item)

        console.print(Rule(style=THEME["dim"]))
        show_results(scored_items, top_n=3)

        console.print("")
        action = fuzzy_prompt("O que fazer agora?", choices=["Refinar Sugestões", "Nova Busca Completa", "Sair"], default="Refinar Sugestões")

        if action == "Sair": break
        elif action == "Nova Busca Completa": console.print(Rule(style=THEME["dim"])); prefs = ask_preferences_panel()
        elif action == "Refinar Sugestões": console.print(Rule(style=THEME["dim"])); prefs = refine_preferences(prefs)

    console.print(Panel(Text(f"🍿 Bom filme/série!", style=HIGHLIGHT_STYLE), box=MINIMAL, padding=(1, 4)))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="CineAI - Recomendações de Filmes e Séries")
    parser.add_argument("--target", type=int, default=2500, help="Número de títulos desejado no catálogo.")
    parser.add_argument("--rebuild", action="store_true", help="Força a reconstrução do cache do catálogo.")
    try:
        args = parser.parse_args()
    except SystemExit:
        args = parser.parse_args([])

    try:
        if not TMDB_BEARER or "eyJ" not in TMDB_BEARER:
            console.print(f"[{THEME['error']}]ERRO: A variável TMDB_BEARER não é uma chave de API válida.[/{THEME['error']}]")
        else:
            cli(args)
    except KeyboardInterrupt:
        console.print(f"\n[{THEME['error']}]Encerrado pelo usuário.[/{THEME['error']}]")
    except Exception as e:
        console.print_exception()